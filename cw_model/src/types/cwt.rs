use super::inference::*;
use cw_parser::cwt::{
    AstCwtBlock, AstCwtIdentifier, AstCwtRule, CwtModule, CwtRange, CwtReferenceType, CwtRuleKey,
    CwtSimpleValue, CwtSimpleValueType, CwtValue, CwtVisitor,
};
use std::collections::{HashMap, HashSet};

/// Converts CWT AST structures to the rich InferredType system using the visitor pattern
pub struct CwtAnalyzer {
    /// Known types registry
    pub types: HashMap<String, TypeDefinition>,
    /// Known enums registry
    pub enums: HashMap<String, EnumDefinition>,
    /// Known value sets registry
    pub value_sets: HashMap<String, HashSet<String>>,
    /// Known aliases registry
    pub aliases: HashMap<String, AliasDefinition>,
    /// Known single aliases registry
    pub single_aliases: HashMap<String, InferredType>,
    /// Current processing context
    current_context: ProcessingContext,
    /// Errors encountered during conversion
    errors: Vec<ConversionError>,
}

#[derive(Debug, Clone, Default)]
struct ProcessingContext {
    /// Are we inside a types block?
    in_types_block: bool,
    /// Are we inside an enums block?
    in_enums_block: bool,
    /// Are we inside a values block?
    in_values_block: bool,
    /// Are we inside an aliases block?
    in_aliases_block: bool,
    /// Current type being processed
    current_type: Option<String>,
    /// Current enum being processed
    current_enum: Option<String>,
    /// Current alias being processed
    current_alias: Option<String>,
    /// Current rule options (cardinality, scope, etc.)
    current_options: RuleOptions,
}

#[derive(Debug, Clone, Default)]
struct RuleOptions {
    /// Cardinality constraint (min..max)
    cardinality: Option<CardinalityConstraint>,
    /// Scope constraint
    scope: Option<Vec<String>>,
    /// Push scope
    push_scope: Option<String>,
    /// Replace scope mappings
    replace_scope: Option<HashMap<String, String>>,
    /// Documentation comment
    documentation: Option<String>,
}

#[derive(Debug, Clone)]
struct CardinalityConstraint {
    min: u32,
    max: Option<u32>, // None means infinite
    is_warning: bool, // ~ prefix means warning-only
}

#[derive(Debug, Clone)]
pub struct TypeDefinition {
    /// Path where this type is found
    pub path: Option<String>,
    /// Name field override
    pub name_field: Option<String>,
    /// Skip root key configuration
    pub skip_root_key: Option<SkipRootKey>,
    /// Subtypes definitions
    pub subtypes: HashMap<String, SubtypeDefinition>,
    /// Localisation requirements
    pub localisation: HashMap<String, LocalisationRequirement>,
    /// Modifiers generated by this type
    pub modifiers: HashMap<String, String>,
    /// Type validation rules
    pub rules: InferredType,
    /// Type-specific options
    pub options: TypeOptions,
}

#[derive(Debug, Clone)]
pub struct SubtypeDefinition {
    /// Conditions that must be met for this subtype
    pub conditions: InferredType,
    /// Additional rules for this subtype
    pub rules: InferredType,
    /// Subtype-specific options
    pub options: SubtypeOptions,
}

#[derive(Debug, Clone, Default)]
pub struct SubtypeOptions {
    /// Display name for this subtype
    pub display_name: Option<String>,
    /// Abbreviation for graph displays
    pub abbreviation: Option<String>,
    /// Scope to push when this subtype is active
    pub push_scope: Option<String>,
    /// Key filter for this subtype
    pub type_key_filter: Option<Vec<String>>,
    /// Starts with filter
    pub starts_with: Option<String>,
}

#[derive(Debug, Clone, Default)]
pub struct TypeOptions {
    /// Whether this type is unique
    pub unique: bool,
    /// Whether to start types from file root
    pub type_per_file: bool,
    /// Path strictness
    pub path_strict: bool,
    /// Specific file to match
    pub path_file: Option<String>,
    /// File extension filter
    pub path_extension: Option<String>,
    /// Graph related types
    pub graph_related_types: Vec<String>,
}

#[derive(Debug, Clone)]
pub enum SkipRootKey {
    /// Skip specific key
    Specific(String),
    /// Skip any key
    Any,
    /// Skip any key except specific ones
    Except(Vec<String>),
    /// Skip multiple levels
    Multiple(Vec<String>),
}

#[derive(Debug, Clone)]
pub struct LocalisationRequirement {
    /// Localisation key pattern
    pub pattern: String,
    /// Whether this localisation is required
    pub required: bool,
    /// Whether this is the primary localisation
    pub primary: bool,
}

#[derive(Debug, Clone)]
pub struct EnumDefinition {
    /// Simple enum values
    pub values: HashSet<String>,
    /// Complex enum configuration
    pub complex: Option<ComplexEnumDefinition>,
}

#[derive(Debug, Clone)]
pub struct ComplexEnumDefinition {
    /// Path to scan for enum values
    pub path: String,
    /// Structure to match for enum extraction
    pub name_structure: InferredType,
    /// Whether to start from file root
    pub start_from_root: bool,
}

#[derive(Debug, Clone)]
pub struct AliasDefinition {
    /// Alias category (e.g., "effect", "trigger")
    pub category: String,
    /// Alias name/key
    pub name: String,
    /// Alias rules
    pub rules: InferredType,
}

impl CwtAnalyzer {
    /// Create a new converter
    pub fn new() -> Self {
        Self {
            types: HashMap::new(),
            enums: HashMap::new(),
            value_sets: HashMap::new(),
            aliases: HashMap::new(),
            single_aliases: HashMap::new(),
            current_context: ProcessingContext::default(),
            errors: Vec::new(),
        }
    }

    /// Convert a CWT module to InferredType definitions
    pub fn convert_module(&mut self, module: &CwtModule) -> Result<(), Vec<ConversionError>> {
        // Visit the entire module using the visitor pattern
        self.visit_module(module);

        if self.errors.is_empty() {
            Ok(())
        } else {
            Err(self.errors.clone())
        }
    }

    /// Convert a CWT simple value to our type system
    fn convert_simple_value(&self, simple: &CwtSimpleValue) -> InferredType {
        let primitive_type = match simple.value_type {
            CwtSimpleValueType::Bool => PrimitiveType::Boolean,
            CwtSimpleValueType::Int => PrimitiveType::Integer,
            CwtSimpleValueType::Float => PrimitiveType::Float,
            CwtSimpleValueType::Scalar => PrimitiveType::Scalar,
            CwtSimpleValueType::PercentageField => PrimitiveType::PercentageField,
            CwtSimpleValueType::Localisation => PrimitiveType::Localisation,
            CwtSimpleValueType::LocalisationSynced => PrimitiveType::LocalisationSynced,
            CwtSimpleValueType::LocalisationInline => PrimitiveType::LocalisationInline,
            CwtSimpleValueType::DateField => PrimitiveType::DateField,
            CwtSimpleValueType::VariableField => PrimitiveType::VariableField,
            CwtSimpleValueType::IntVariableField => PrimitiveType::IntVariableField,
            CwtSimpleValueType::ValueField => PrimitiveType::ValueField,
            CwtSimpleValueType::IntValueField => PrimitiveType::IntValueField,
            CwtSimpleValueType::ScopeField => PrimitiveType::ScopeField,
            CwtSimpleValueType::Filepath => PrimitiveType::Filepath,
            CwtSimpleValueType::Icon => PrimitiveType::Icon,
        };

        let mut base_type = InferredType::Primitive(primitive_type);

        // Apply range constraints if present
        if let Some(range) = &simple.range {
            base_type = self.apply_range_constraints(base_type, range);
        }

        // Apply current rule options
        if let Some(cardinality) = &self.current_context.current_options.cardinality {
            base_type = self.apply_cardinality_constraints(base_type, cardinality);
        }

        base_type
    }

    /// Apply range constraints to a type
    fn apply_range_constraints(&self, base_type: InferredType, range: &CwtRange) -> InferredType {
        let inference_range = Range {
            min: match &range.min {
                cw_parser::cwt::CwtRangeBound::Int(s) => {
                    RangeBound::Integer(s.parse().unwrap_or(0))
                }
                cw_parser::cwt::CwtRangeBound::Float(s) => {
                    RangeBound::Float(s.parse().unwrap_or(0.0))
                }
                cw_parser::cwt::CwtRangeBound::Infinity(false) => RangeBound::NegInfinity,
                cw_parser::cwt::CwtRangeBound::Infinity(true) => RangeBound::PosInfinity,
            },
            max: match &range.max {
                cw_parser::cwt::CwtRangeBound::Int(s) => {
                    RangeBound::Integer(s.parse().unwrap_or(0))
                }
                cw_parser::cwt::CwtRangeBound::Float(s) => {
                    RangeBound::Float(s.parse().unwrap_or(0.0))
                }
                cw_parser::cwt::CwtRangeBound::Infinity(false) => RangeBound::NegInfinity,
                cw_parser::cwt::CwtRangeBound::Infinity(true) => RangeBound::PosInfinity,
            },
        };

        match base_type {
            InferredType::Primitive(PrimitiveType::Integer) => {
                InferredType::Constrained(ConstrainedType {
                    base_type: Box::new(base_type),
                    range: Some(inference_range),
                    cardinality: None,
                    options: Vec::new(),
                })
            }
            InferredType::Primitive(PrimitiveType::Float) => {
                InferredType::Constrained(ConstrainedType {
                    base_type: Box::new(base_type),
                    range: Some(inference_range),
                    cardinality: None,
                    options: Vec::new(),
                })
            }
            _ => base_type,
        }
    }

    /// Apply cardinality constraints to a type
    fn apply_cardinality_constraints(
        &self,
        base_type: InferredType,
        cardinality: &CardinalityConstraint,
    ) -> InferredType {
        if cardinality.max == Some(1) && cardinality.min == 0 {
            // Optional type - use constrained type with cardinality
            InferredType::Constrained(ConstrainedType {
                base_type: Box::new(base_type),
                cardinality: Some(Cardinality::optional()),
                range: None,
                options: Vec::new(),
            })
        } else if cardinality.max.is_none() || cardinality.max.unwrap() > 1 {
            // Array type
            InferredType::Array(ArrayType {
                element_type: Box::new(base_type),
                cardinality: Cardinality::new(cardinality.min, cardinality.max),
            })
        } else {
            base_type
        }
    }

    /// Convert a CWT identifier to our type system
    fn convert_identifier(&self, identifier: &AstCwtIdentifier) -> InferredType {
        let reference_type = match &identifier.identifier_type {
            CwtReferenceType::TypeRef => ReferenceType::TypeRef {
                type_key: identifier.name.raw_value().to_string(),
                prefix: None,
                suffix: None,
            },
            CwtReferenceType::TypeRefWithPrefixSuffix(prefix, suffix) => ReferenceType::TypeRef {
                type_key: identifier.name.raw_value().to_string(),
                prefix: Some(prefix.to_string()),
                suffix: Some(suffix.to_string()),
            },
            CwtReferenceType::Enum => ReferenceType::Enum {
                key: identifier.name.raw_value().to_string(),
            },
            CwtReferenceType::Scope => ReferenceType::Scope {
                key: identifier.name.raw_value().to_string(),
            },
            CwtReferenceType::Value => ReferenceType::Value {
                key: identifier.name.raw_value().to_string(),
            },
            CwtReferenceType::ValueSet => ReferenceType::ValueSet {
                key: identifier.name.raw_value().to_string(),
            },
            _ => ReferenceType::TypeRef {
                type_key: identifier.name.raw_value().to_string(),
                prefix: None,
                suffix: None,
            },
        };

        InferredType::Reference(reference_type)
    }

    /// Convert a CWT block to our type system
    fn convert_block(&mut self, block: &AstCwtBlock) -> InferredType {
        let mut properties = HashMap::new();

        // Process all items in the block
        for item in &block.items {
            match item {
                cw_parser::cwt::AstCwtExpression::Rule(rule) => {
                    let key = rule.key.name();
                    let value_type = self.convert_value(&rule.value);
                    let property_def = PropertyDefinition {
                        property_type: Box::new(value_type),
                        cardinality: self
                            .current_context
                            .current_options
                            .cardinality
                            .as_ref()
                            .map(|c| Cardinality::new(c.min, c.max)),
                        options: Vec::new(),
                        documentation: self.current_context.current_options.documentation.clone(),
                    };
                    properties.insert(key.to_string(), property_def);
                }
                cw_parser::cwt::AstCwtExpression::String(s) => {
                    // Handle string literals in blocks
                    let value = s.raw_value().to_string();
                    let property_def = PropertyDefinition {
                        property_type: Box::new(InferredType::Literal(value.clone())),
                        cardinality: None,
                        options: Vec::new(),
                        documentation: None,
                    };
                    properties.insert(value, property_def);
                }
                cw_parser::cwt::AstCwtExpression::Identifier(id) => {
                    // Handle identifiers in blocks
                    let value = id.name.raw_value().to_string();
                    let property_def = PropertyDefinition {
                        property_type: Box::new(InferredType::Literal(value.clone())),
                        cardinality: None,
                        options: Vec::new(),
                        documentation: None,
                    };
                    properties.insert(value, property_def);
                }
                _ => {
                    // Handle other expression types as needed
                }
            }
        }

        InferredType::Object(ObjectType {
            properties,
            subtypes: HashMap::new(),
            extensible: true,
            localisation: None,
            modifiers: None,
        })
    }

    /// Convert a CWT value to our type system
    fn convert_value(&mut self, value: &CwtValue) -> InferredType {
        match value {
            CwtValue::Simple(simple) => self.convert_simple_value(simple),
            CwtValue::Identifier(identifier) => self.convert_identifier(identifier),
            CwtValue::Block(block) => self.convert_block(block),
            CwtValue::String(s) => InferredType::Literal(s.raw_value().to_string()),
        }
    }

    /// Parse rule options from rule comments
    fn parse_rule_options(&mut self, rule: &AstCwtRule) -> RuleOptions {
        let mut options = RuleOptions::default();

        // Process all CWT options from the parsed AST
        for cwt_option in &rule.options {
            match &cwt_option.option_type {
                cw_parser::cwt::CwtOptionType::Cardinality { min, max } => {
                    options.cardinality = Some(CardinalityConstraint {
                        min: *min,
                        max: match max {
                            cw_parser::cwt::CwtCardinalityMax::Number(n) => Some(*n),
                            cw_parser::cwt::CwtCardinalityMax::Infinity => None,
                        },
                        is_warning: false,
                    });
                }
                cw_parser::cwt::CwtOptionType::SoftCardinality { min, max } => {
                    options.cardinality = Some(CardinalityConstraint {
                        min: *min,
                        max: match max {
                            cw_parser::cwt::CwtCardinalityMax::Number(n) => Some(*n),
                            cw_parser::cwt::CwtCardinalityMax::Infinity => None,
                        },
                        is_warning: true,
                    });
                }
                cw_parser::cwt::CwtOptionType::PushScope { scope } => {
                    options.push_scope = Some(scope.to_string());
                }
                cw_parser::cwt::CwtOptionType::ReplaceScope { replacements } => {
                    let mut replace_map = HashMap::new();
                    for replacement in replacements {
                        replace_map
                            .insert(replacement.from.to_string(), replacement.to.to_string());
                    }
                    options.replace_scope = Some(replace_map);
                }
                cw_parser::cwt::CwtOptionType::Scope { scopes } => {
                    options.scope = Some(scopes.iter().map(|s| s.to_string()).collect());
                }
                _ => {
                    // Handle other option types as needed
                }
            }
        }

        // Extract documentation from the rule
        if let Some(doc) = &rule.documentation {
            options.documentation = Some(doc.text.to_string());
        }

        // Default cardinality if none specified
        if options.cardinality.is_none() {
            options.cardinality = Some(CardinalityConstraint {
                min: 1,
                max: Some(1),
                is_warning: false,
            });
        }

        options
    }

    /// Get all defined types
    pub fn get_types(&self) -> &HashMap<String, TypeDefinition> {
        &self.types
    }

    /// Get all defined enums
    pub fn get_enums(&self) -> &HashMap<String, EnumDefinition> {
        &self.enums
    }

    /// Get all defined value sets
    pub fn get_value_sets(&self) -> &HashMap<String, HashSet<String>> {
        &self.value_sets
    }

    /// Get all defined aliases
    pub fn get_aliases(&self) -> &HashMap<String, AliasDefinition> {
        &self.aliases
    }

    /// Get single aliases
    pub fn get_single_aliases(&self) -> &HashMap<String, InferredType> {
        &self.single_aliases
    }

    /// Get conversion errors
    pub fn get_errors(&self) -> &Vec<ConversionError> {
        &self.errors
    }
}

impl<'a> CwtVisitor<'a> for CwtAnalyzer {
    fn visit_rule(&mut self, rule: &AstCwtRule<'a>) {
        let key = rule.key.name();

        // Parse rule options
        self.current_context.current_options = self.parse_rule_options(rule);

        // Handle special top-level sections
        match key {
            "types" => {
                self.current_context.in_types_block = true;
                self.walk_rule(rule);
                self.current_context.in_types_block = false;
            }
            "enums" => {
                self.current_context.in_enums_block = true;
                self.walk_rule(rule);
                self.current_context.in_enums_block = false;
            }
            "values" => {
                self.current_context.in_values_block = true;
                self.walk_rule(rule);
                self.current_context.in_values_block = false;
            }
            "aliases" => {
                self.current_context.in_aliases_block = true;
                self.walk_rule(rule);
                self.current_context.in_aliases_block = false;
            }
            _ => {
                // Check for typed identifiers in the rule key
                if let CwtRuleKey::Identifier(identifier) = &rule.key {
                    match &identifier.identifier_type {
                        CwtReferenceType::Type => {
                            self.process_type_definition(rule);
                        }
                        CwtReferenceType::Enum => {
                            self.process_enum_definition(rule);
                        }
                        CwtReferenceType::ComplexEnum => {
                            self.process_enum_definition(rule);
                        }
                        CwtReferenceType::ValueSet => {
                            self.process_value_set_definition(rule);
                        }
                        CwtReferenceType::Alias => {
                            self.process_alias_definition(rule);
                        }
                        CwtReferenceType::SingleAlias => {
                            self.process_alias_definition(rule);
                        }
                        _ => {
                            // Other identifier types or when inside blocks
                            if self.current_context.in_types_block {
                                self.process_type_definition(rule);
                            } else if self.current_context.in_enums_block {
                                self.process_enum_definition(rule);
                            } else if self.current_context.in_values_block {
                                self.process_value_set_definition(rule);
                            } else if self.current_context.in_aliases_block {
                                self.process_alias_definition(rule);
                            } else {
                                // Regular rule - convert to type definition
                                let rule_type = self.convert_value(&rule.value);
                                let type_def = TypeDefinition {
                                    path: None,
                                    name_field: None,
                                    skip_root_key: None,
                                    subtypes: HashMap::new(),
                                    localisation: HashMap::new(),
                                    modifiers: HashMap::new(),
                                    rules: rule_type,
                                    options: TypeOptions::default(),
                                };
                                self.types.insert(key.to_string(), type_def);
                            }
                        }
                    }
                } else {
                    // Handle string keys or when inside blocks
                    if self.current_context.in_types_block {
                        self.process_type_definition(rule);
                    } else if self.current_context.in_enums_block {
                        self.process_enum_definition(rule);
                    } else if self.current_context.in_values_block {
                        self.process_value_set_definition(rule);
                    } else if self.current_context.in_aliases_block {
                        self.process_alias_definition(rule);
                    } else {
                        // Regular rule - convert to type definition
                        let rule_type = self.convert_value(&rule.value);
                        let type_def = TypeDefinition {
                            path: None,
                            name_field: None,
                            skip_root_key: None,
                            subtypes: HashMap::new(),
                            localisation: HashMap::new(),
                            modifiers: HashMap::new(),
                            rules: rule_type,
                            options: TypeOptions::default(),
                        };
                        self.types.insert(key.to_string(), type_def);
                    }
                }
            }
        }
    }

    fn visit_block(&mut self, block: &AstCwtBlock<'a>) {
        // Traverse all items in the block
        for item in &block.items {
            match item {
                cw_parser::cwt::AstCwtExpression::Rule(rule) => {
                    self.visit_rule(rule);
                }
                cw_parser::cwt::AstCwtExpression::Block(inner_block) => {
                    self.visit_block(inner_block);
                }
                cw_parser::cwt::AstCwtExpression::String(_) => {
                    // String literals don't need further processing in visitor
                }
                cw_parser::cwt::AstCwtExpression::Identifier(_) => {
                    // Identifiers don't need further processing in visitor
                }
            }
        }
    }
}

impl CwtAnalyzer {
    /// Process a type definition
    fn process_type_definition(&mut self, rule: &AstCwtRule) {
        let key = rule.key.name();

        // Check if this is a typed identifier
        if let CwtRuleKey::Identifier(identifier) = &rule.key {
            if matches!(identifier.identifier_type, CwtReferenceType::Type) {
                let type_name = identifier.name.raw_value();
                self.current_context.current_type = Some(type_name.to_string());

                // Convert the type definition
                let mut type_def = TypeDefinition {
                    path: None,
                    name_field: None,
                    skip_root_key: None,
                    subtypes: HashMap::new(),
                    localisation: HashMap::new(),
                    modifiers: HashMap::new(),
                    rules: self.convert_value(&rule.value),
                    options: TypeOptions::default(),
                };

                // Extract path and other options from the block
                if let CwtValue::Block(block) = &rule.value {
                    self.extract_type_options(&mut type_def, block);
                }

                self.types.insert(type_name.to_string(), type_def);
                self.current_context.current_type = None;
                return;
            }
        }

        // Legacy string-based handling for backwards compatibility
        if key.starts_with("type[") && key.ends_with("]") {
            let type_name = &key[5..key.len() - 1];
            self.current_context.current_type = Some(type_name.to_string());

            // Convert the type definition
            let mut type_def = TypeDefinition {
                path: None,
                name_field: None,
                skip_root_key: None,
                subtypes: HashMap::new(),
                localisation: HashMap::new(),
                modifiers: HashMap::new(),
                rules: self.convert_value(&rule.value),
                options: TypeOptions::default(),
            };

            // Extract path and other options from the block
            if let CwtValue::Block(block) = &rule.value {
                self.extract_type_options(&mut type_def, block);
            }

            self.types.insert(type_name.to_string(), type_def);
            self.current_context.current_type = None;
        }
    }

    /// Process an enum definition
    fn process_enum_definition(&mut self, rule: &AstCwtRule) {
        let key = rule.key.name();

        // Check if this is a typed identifier
        if let CwtRuleKey::Identifier(identifier) = &rule.key {
            match identifier.identifier_type {
                CwtReferenceType::Enum => {
                    let enum_name = identifier.name.raw_value();
                    self.current_context.current_enum = Some(enum_name.to_string());

                    let mut enum_def = EnumDefinition {
                        values: HashSet::new(),
                        complex: None,
                    };

                    // Extract enum values from the block
                    if let CwtValue::Block(block) = &rule.value {
                        self.extract_enum_values(&mut enum_def, block);
                    }

                    self.enums.insert(enum_name.to_string(), enum_def);
                    self.current_context.current_enum = None;
                    return;
                }
                CwtReferenceType::ComplexEnum => {
                    let enum_name = identifier.name.raw_value();

                    let mut enum_def = EnumDefinition {
                        values: HashSet::new(),
                        complex: Some(ComplexEnumDefinition {
                            path: String::new(),
                            name_structure: InferredType::Object(ObjectType {
                                properties: HashMap::new(),
                                subtypes: HashMap::new(),
                                extensible: true,
                                localisation: None,
                                modifiers: None,
                            }),
                            start_from_root: false,
                        }),
                    };

                    // Extract complex enum configuration
                    if let CwtValue::Block(block) = &rule.value {
                        self.extract_complex_enum_config(&mut enum_def, block);
                    }

                    self.enums.insert(enum_name.to_string(), enum_def);
                    return;
                }
                _ => {}
            }
        }

        // Legacy string-based handling for backwards compatibility
        if key.starts_with("enum[") && key.ends_with("]") {
            let enum_name = &key[5..key.len() - 1];
            self.current_context.current_enum = Some(enum_name.to_string());

            let mut enum_def = EnumDefinition {
                values: HashSet::new(),
                complex: None,
            };

            // Extract enum values from the block
            if let CwtValue::Block(block) = &rule.value {
                self.extract_enum_values(&mut enum_def, block);
            }

            self.enums.insert(enum_name.to_string(), enum_def);
            self.current_context.current_enum = None;
        } else if key.starts_with("complex_enum[") && key.ends_with("]") {
            let enum_name = &key[13..key.len() - 1];

            let mut enum_def = EnumDefinition {
                values: HashSet::new(),
                complex: Some(ComplexEnumDefinition {
                    path: String::new(),
                    name_structure: InferredType::Object(ObjectType {
                        properties: HashMap::new(),
                        subtypes: HashMap::new(),
                        extensible: true,
                        localisation: None,
                        modifiers: None,
                    }),
                    start_from_root: false,
                }),
            };

            // Extract complex enum configuration
            if let CwtValue::Block(block) = &rule.value {
                self.extract_complex_enum_config(&mut enum_def, block);
            }

            self.enums.insert(enum_name.to_string(), enum_def);
        }
    }

    /// Process a value set definition
    fn process_value_set_definition(&mut self, rule: &AstCwtRule) {
        let key = rule.key.name();

        // Check if this is a typed identifier
        if let CwtRuleKey::Identifier(identifier) = &rule.key {
            if matches!(identifier.identifier_type, CwtReferenceType::ValueSet) {
                let value_set_name = identifier.name.raw_value();
                let mut values = HashSet::new();

                // Extract values from the block
                if let CwtValue::Block(block) = &rule.value {
                    for item in &block.items {
                        if let cw_parser::cwt::AstCwtExpression::String(s) = item {
                            values.insert(s.raw_value().to_string());
                        }
                    }
                }

                self.value_sets.insert(value_set_name.to_string(), values);
                return;
            }
        }

        // Legacy string-based handling for backwards compatibility
        if key.starts_with("value_set[") && key.ends_with("]") {
            let value_set_name = &key[10..key.len() - 1];
            let mut values = HashSet::new();

            // Extract values from the block
            if let CwtValue::Block(block) = &rule.value {
                for item in &block.items {
                    if let cw_parser::cwt::AstCwtExpression::String(s) = item {
                        values.insert(s.raw_value().to_string());
                    }
                }
            }

            self.value_sets.insert(value_set_name.to_string(), values);
        }
    }

    /// Process an alias definition
    fn process_alias_definition(&mut self, rule: &AstCwtRule) {
        let key = rule.key.name();

        // Check if this is a typed identifier
        if let CwtRuleKey::Identifier(identifier) = &rule.key {
            match identifier.identifier_type {
                CwtReferenceType::Alias => {
                    let alias_full = identifier.name.raw_value();
                    if let Some((category, name)) = alias_full.split_once(':') {
                        let alias_def = AliasDefinition {
                            category: category.to_string(),
                            name: name.to_string(),
                            rules: self.convert_value(&rule.value),
                        };

                        self.aliases
                            .insert(format!("{}:{}", category, name), alias_def);
                    }
                    return;
                }
                CwtReferenceType::SingleAlias => {
                    let alias_name = identifier.name.raw_value();
                    let alias_type = self.convert_value(&rule.value);

                    self.single_aliases
                        .insert(alias_name.to_string(), alias_type);
                    return;
                }
                _ => {}
            }
        }

        // Legacy string-based handling for backwards compatibility
        if key.starts_with("alias[") && key.ends_with("]") {
            let alias_full = &key[6..key.len() - 1];
            if let Some((category, name)) = alias_full.split_once(':') {
                let alias_def = AliasDefinition {
                    category: category.to_string(),
                    name: name.to_string(),
                    rules: self.convert_value(&rule.value),
                };

                self.aliases
                    .insert(format!("{}:{}", category, name), alias_def);
            }
        } else if key.starts_with("single_alias[") && key.ends_with("]") {
            let alias_name = &key[13..key.len() - 1];
            let alias_type = self.convert_value(&rule.value);

            self.single_aliases
                .insert(alias_name.to_string(), alias_type);
        }
    }

    /// Extract type options from a type definition block
    fn extract_type_options(&mut self, type_def: &mut TypeDefinition, block: &AstCwtBlock) {
        for item in &block.items {
            if let cw_parser::cwt::AstCwtExpression::Rule(rule) = item {
                let key = rule.key.name();
                match key {
                    "path" => {
                        if let CwtValue::String(s) = &rule.value {
                            type_def.path = Some(s.raw_value().to_string());
                        }
                    }
                    "name_field" => {
                        if let CwtValue::String(s) = &rule.value {
                            type_def.name_field = Some(s.raw_value().to_string());
                        }
                    }
                    "unique" => {
                        if let CwtValue::Simple(simple) = &rule.value {
                            if simple.value_type == CwtSimpleValueType::Bool {
                                type_def.options.unique = true;
                            }
                        }
                    }
                    "type_per_file" => {
                        if let CwtValue::Simple(simple) = &rule.value {
                            if simple.value_type == CwtSimpleValueType::Bool {
                                type_def.options.type_per_file = true;
                            }
                        }
                    }
                    "localisation" => {
                        if let CwtValue::Block(loc_block) = &rule.value {
                            self.extract_localisation_requirements(type_def, loc_block);
                        }
                    }
                    "modifiers" => {
                        if let CwtValue::Block(mod_block) = &rule.value {
                            self.extract_modifier_definitions(type_def, mod_block);
                        }
                    }
                    _ if key.starts_with("subtype[") && key.ends_with("]") => {
                        let subtype_name = &key[8..key.len() - 1];
                        let subtype_def = SubtypeDefinition {
                            conditions: self.convert_value(&rule.value),
                            rules: InferredType::Object(ObjectType {
                                properties: HashMap::new(),
                                subtypes: HashMap::new(),
                                extensible: true,
                                localisation: None,
                                modifiers: None,
                            }),
                            options: SubtypeOptions::default(),
                        };
                        type_def
                            .subtypes
                            .insert(subtype_name.to_string(), subtype_def);
                    }
                    _ => {
                        // Regular field in type definition
                    }
                }
            }
        }
    }

    /// Extract enum values from an enum definition block
    fn extract_enum_values(&mut self, enum_def: &mut EnumDefinition, block: &AstCwtBlock) {
        for item in &block.items {
            match item {
                cw_parser::cwt::AstCwtExpression::String(s) => {
                    enum_def.values.insert(s.raw_value().to_string());
                }
                cw_parser::cwt::AstCwtExpression::Identifier(id) => {
                    enum_def.values.insert(id.name.raw_value().to_string());
                }
                _ => {}
            }
        }
    }

    /// Extract complex enum configuration
    fn extract_complex_enum_config(&mut self, enum_def: &mut EnumDefinition, block: &AstCwtBlock) {
        if let Some(ref mut complex) = enum_def.complex {
            for item in &block.items {
                if let cw_parser::cwt::AstCwtExpression::Rule(rule) = item {
                    let key = rule.key.name();
                    match key {
                        "path" => {
                            if let CwtValue::String(s) = &rule.value {
                                complex.path = s.raw_value().to_string();
                            }
                        }
                        "start_from_root" => {
                            if let CwtValue::Simple(simple) = &rule.value {
                                if simple.value_type == CwtSimpleValueType::Bool {
                                    complex.start_from_root = true;
                                }
                            }
                        }
                        "name" => {
                            complex.name_structure = self.convert_value(&rule.value);
                        }
                        _ => {}
                    }
                }
            }
        }
    }

    /// Extract localisation requirements from a type definition
    fn extract_localisation_requirements(
        &mut self,
        type_def: &mut TypeDefinition,
        block: &AstCwtBlock,
    ) {
        for item in &block.items {
            if let cw_parser::cwt::AstCwtExpression::Rule(rule) = item {
                let key = rule.key.name();
                if let CwtValue::String(pattern) = &rule.value {
                    let requirement = LocalisationRequirement {
                        pattern: pattern.raw_value().to_string(),
                        required: false, // TODO: Parse from comments
                        primary: false,  // TODO: Parse from comments
                    };
                    type_def.localisation.insert(key.to_string(), requirement);
                }
            }
        }
    }

    /// Extract modifier definitions from a type definition
    fn extract_modifier_definitions(&mut self, type_def: &mut TypeDefinition, block: &AstCwtBlock) {
        for item in &block.items {
            if let cw_parser::cwt::AstCwtExpression::Rule(rule) = item {
                let key = rule.key.name();
                if let CwtValue::String(scope) = &rule.value {
                    type_def
                        .modifiers
                        .insert(key.to_string(), scope.raw_value().to_string());
                }
            }
        }
    }
}

impl Default for CwtAnalyzer {
    fn default() -> Self {
        Self::new()
    }
}

/// Errors that can occur during CWT conversion
#[derive(Debug, Clone, PartialEq)]
pub enum ConversionError {
    InvalidRange,
    InvalidCardinality(String),
    InvalidSubtypeFormat,
    InvalidEnumFormat,
    InvalidAliasFormat,
    UnsupportedFeature(String),
    MissingReference(String),
    InvalidTypeDefinition(String),
    InvalidComplexEnum(String),
}

impl std::fmt::Display for ConversionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            ConversionError::InvalidRange => write!(f, "Invalid range specification"),
            ConversionError::InvalidCardinality(card) => write!(f, "Invalid cardinality: {}", card),
            ConversionError::InvalidSubtypeFormat => write!(f, "Invalid subtype format"),
            ConversionError::InvalidEnumFormat => write!(f, "Invalid enum format"),
            ConversionError::InvalidAliasFormat => write!(f, "Invalid alias format"),
            ConversionError::UnsupportedFeature(feature) => {
                write!(f, "Unsupported CWT feature: {}", feature)
            }
            ConversionError::MissingReference(ref_name) => {
                write!(f, "Missing reference: {}", ref_name)
            }
            ConversionError::InvalidTypeDefinition(type_name) => {
                write!(f, "Invalid type definition: {}", type_name)
            }
            ConversionError::InvalidComplexEnum(enum_name) => {
                write!(f, "Invalid complex enum: {}", enum_name)
            }
        }
    }
}

impl std::error::Error for ConversionError {}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_converter_creation() {
        let converter = CwtAnalyzer::new();
        assert!(converter.types.is_empty());
        assert!(converter.enums.is_empty());
        assert!(converter.value_sets.is_empty());
        assert!(converter.aliases.is_empty());
    }

    #[test]
    fn test_range_constraints() {
        let converter = CwtAnalyzer::new();
        let range = cw_parser::cwt::CwtRange {
            min: cw_parser::cwt::CwtRangeBound::Int("0"),
            max: cw_parser::cwt::CwtRangeBound::Int("10"),
            span: 0..10,
        };
        let base_type = InferredType::Primitive(PrimitiveType::Integer);

        let constrained = converter.apply_range_constraints(base_type, &range);

        match constrained {
            InferredType::Constrained(constraint) => {
                assert!(constraint.range.is_some());
                let range_constraint = constraint.range.as_ref().unwrap();
                assert_eq!(range_constraint.min, RangeBound::Integer(0));
                assert_eq!(range_constraint.max, RangeBound::Integer(10));
            }
            _ => panic!("Expected constrained type"),
        }
    }
}
