//! Type definitions for CWT analysis
//!
//! This module contains all the data structures used to represent CWT type definitions,
//! enums, aliases, and their associated metadata.

use serde::{Deserialize, Serialize};

use std::{
    collections::{HashMap, HashSet},
    str::FromStr,
    sync::Arc,
};

use crate::{CwtAnalyzer, CwtOptions, CwtType, ModifierSpec, RuleOptions, Subtype};

/// Definition of a CWT type
#[derive(Debug, Clone)]
pub struct TypeDefinition {
    /// Path where this type is found
    pub path: Option<String>,

    /// Name field override
    pub name_field: Option<String>,

    /// Skip root key configuration
    pub skip_root_key: Option<SkipRootKey>,

    /// Subtypes definitions
    pub subtypes: HashMap<String, Subtype>,

    /// Localisation requirements
    pub localisation: HashMap<String, LocalisationRequirement>,

    /// Modifiers generated by this type
    pub modifiers: ModifierSpec,

    /// Type validation rules
    pub rules: Arc<CwtType>,

    /// Type-specific options
    pub options: TypeOptions,

    /// Rule options
    pub rule_options: RuleOptions,
}

/// Options for types
#[derive(Debug, Clone, Default)]
pub struct TypeOptions {
    /// Whether this type is unique
    pub unique: bool,

    /// Whether to start types from file root
    pub type_per_file: bool,

    /// Path strictness
    pub path_strict: bool,

    /// Specific file to match
    pub path_file: Option<String>,

    /// File extension filter
    pub path_extension: Option<String>,

    /// Graph related types
    pub graph_related_types: Vec<String>,

    /// Starts with filter
    pub starts_with: Option<String>,

    /// Severity level for errors
    pub severity: Option<SeverityLevel>,

    /// Type key filter
    pub type_key_filter: Option<TypeKeyFilter>,
}

impl TypeOptions {
    /// Merge another TypeOptions into this one, preferring non-default values
    pub fn merge_with(&mut self, other: TypeOptions) {
        // For boolean flags, take true if either is true
        self.unique = self.unique || other.unique;
        self.type_per_file = self.type_per_file || other.type_per_file;
        self.path_strict = self.path_strict || other.path_strict;

        // For optional values, prefer non-None
        if other.path_file.is_some() {
            self.path_file = other.path_file;
        }
        if other.path_extension.is_some() {
            self.path_extension = other.path_extension;
        }
        if other.starts_with.is_some() {
            self.starts_with = other.starts_with;
        }
        if other.severity.is_some() {
            self.severity = other.severity;
        }
        if other.type_key_filter.is_some() {
            self.type_key_filter = other.type_key_filter;
        }

        // For vectors, extend rather than replace
        self.graph_related_types.extend(other.graph_related_types);
    }
}

/// Type key filter configuration
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub enum TypeKeyFilter {
    /// Must have specific key
    Specific(String),
    /// Must have one of these keys
    OneOf(Vec<String>),
    /// Must not have specific key
    Not(String),
}

/// Severity levels for validation
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub enum SeverityLevel {
    Error,
    Warning,
    Information,
    Hint,
}

impl FromStr for SeverityLevel {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "error" => Ok(SeverityLevel::Error),
            "warning" => Ok(SeverityLevel::Warning),
            "information" => Ok(SeverityLevel::Information),
            "hint" => Ok(SeverityLevel::Hint),
            "info" => Ok(SeverityLevel::Information),
            _ => Err(format!("Invalid severity level: {}", s)),
        }
    }
}

/// Skip root key configuration
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum SkipRootKey {
    /// Skip specific key
    Specific(String),
    /// Skip any key
    Any,
    /// Skip any key except specific ones
    Except(Vec<String>),
    /// Skip multiple levels in sequence
    Multiple(Vec<String>),
}

/// Localisation requirement for a type
#[derive(Debug, Clone)]
pub struct LocalisationRequirement {
    /// Localisation key pattern
    pub pattern: String,
    /// Whether this localisation is required
    pub required: bool,
    /// Whether this is the primary localisation
    pub primary: bool,
    /// Subtype-specific localisation
    pub subtypes: HashMap<String, HashMap<String, String>>,
}

impl LocalisationRequirement {
    /// Create a new localisation requirement
    pub fn new(pattern: String) -> Self {
        Self {
            pattern,
            required: false,
            primary: false,
            subtypes: HashMap::new(),
        }
    }

    /// Create a required localisation requirement
    pub fn required(pattern: String) -> Self {
        Self {
            pattern,
            required: true,
            primary: false,
            subtypes: HashMap::new(),
        }
    }

    /// Create a primary localisation requirement
    pub fn primary(pattern: String) -> Self {
        Self {
            pattern,
            required: false,
            primary: true,
            subtypes: HashMap::new(),
        }
    }
}

/// Definition of a CWT enum
#[derive(Debug, Clone)]
pub struct EnumDefinition {
    /// Simple enum values
    pub values: HashSet<String>,
    /// Complex enum configuration
    pub complex: Option<ComplexEnumDefinition>,
}

/// Definition of a CWT scope
#[derive(Debug, Clone)]
pub struct ScopeDefinition {
    /// Name of the scope
    pub name: String,
    /// Aliases for this scope
    pub aliases: Vec<String>,
}

/// Definition of a CWT scope group
#[derive(Debug, Clone)]
pub struct ScopeGroupDefinition {
    /// Name of the scope group
    pub name: String,
    /// Member scopes in this group
    pub members: Vec<String>,
}

/// Configuration for complex enums
#[derive(Debug, Clone)]
pub struct ComplexEnumDefinition {
    /// Path to scan for enum values
    pub path: String,
    /// Structure to match for enum extraction
    pub name_structure: Arc<CwtType>,
    /// Whether to start from file root
    pub start_from_root: bool,
}

/// Definition of a CWT alias
#[derive(Debug, Clone)]
pub struct AliasDefinition {
    /// Alias category (e.g., "effect", "trigger")
    pub category: String,

    /// Alias name/key
    pub name: String,

    /// Alias to this type
    pub to: Arc<CwtType>,

    /// Options from the alias definition (e.g., push_scope, replace_scope)
    pub options: CwtOptions,
}

/// Definition of a CWT link
#[derive(Debug, Clone)]
pub struct LinkDefinition {
    /// Link name/key
    pub name: String,
    /// Description of the link
    pub desc: Option<String>,
    /// Whether this link is generated from data
    pub from_data: bool,
    /// Type of link (scope, both, value)
    pub link_type: LinkType,
    /// Data source for generated links
    pub data_source: Option<String>,
    /// Mandatory prefix for link values
    pub prefix: Option<String>,
    /// Input scopes this link can be used from
    pub input_scopes: Vec<String>,
    /// Output scope this link results in
    pub output_scope: String,
}

/// Type of link
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum LinkType {
    /// Scope link
    Scope,
    /// Value link
    Value,
    /// Both scope and value
    Both,
}

impl TypeDefinition {
    /// Create a new type definition with default values
    pub fn new(rules: Arc<CwtType>) -> Self {
        Self {
            path: None,
            name_field: None,
            skip_root_key: None,
            subtypes: HashMap::new(),
            localisation: HashMap::new(),
            modifiers: ModifierSpec {
                modifiers: HashMap::new(),
                subtypes: HashMap::new(),
            },
            rules,
            options: TypeOptions::default(),
            rule_options: RuleOptions::default(),
        }
    }

    /// Check if this type has a specific path
    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    /// Check if this type has subtypes
    pub fn has_subtypes(&self) -> bool {
        !self.subtypes.is_empty()
    }

    /// Check if this type has localisation requirements
    pub fn has_localisation(&self) -> bool {
        !self.localisation.is_empty()
    }

    /// Update the rules field to include subtypes
    /// This should be called after all subtypes have been parsed
    pub fn finalize_with_subtypes(&mut self) {
        if let CwtType::Block(block_type) = Arc::<CwtType>::make_mut(&mut self.rules) {
            // Merge subtypes into the block type
            for (subtype_name, subtype_def) in &self.subtypes {
                block_type
                    .subtypes
                    .insert(subtype_name.clone(), subtype_def.clone());

                // Also insert the inverted subtype
                let mut inverted = subtype_def.clone();
                inverted.is_inverted = true;

                block_type
                    .subtypes
                    .insert(format!("!{}", subtype_name), inverted);
            }
        }
    }

    pub fn finalize_subtype_properties(&mut self) {
        // Merge subtype_properties with existing subtypes.allowed_properties
        // This adds game data properties to allowed_properties while preserving CWT schema condition_properties
        if let CwtType::Block(block_type) = Arc::<CwtType>::make_mut(&mut self.rules) {
            for (subtype_name, properties) in block_type.subtype_properties.iter() {
                if let Some(subtype) = block_type.subtypes.get_mut(subtype_name) {
                    // Merge properties instead of overwriting
                    for (prop_key, prop_value) in properties {
                        subtype
                            .allowed_properties
                            .insert(prop_key.clone(), prop_value.clone());
                    }
                }
            }

            for (subtype_name, pattern_properties) in block_type.subtype_pattern_properties.iter() {
                if let Some(subtype) = block_type.subtypes.get_mut(subtype_name) {
                    for pattern_property in pattern_properties {
                        subtype
                            .allowed_pattern_properties
                            .push(pattern_property.clone());
                    }
                }
            }
        }
    }

    /// Merge another TypeDefinition into this one
    /// The other definition's rules will replace this one's rules,
    /// but metadata will be merged intelligently
    pub fn merge_with(&mut self, other: TypeDefinition) {
        // Always take the new rules
        if *other.rules != CwtType::Unknown {
            self.rules = other.rules;
        }

        // Merge metadata - prefer non-None values
        if other.path.is_some() {
            self.path = other.path;
        }

        if self.path.is_none() {
            panic!("Type has no path: {}", self.name_field.clone().unwrap());
        }

        if other.name_field.is_some() {
            self.name_field = other.name_field;
        }
        if other.skip_root_key.is_some() {
            self.skip_root_key = other.skip_root_key;
        }

        // Merge collections - extend rather than replace
        for (key, subtype) in other.subtypes {
            self.subtypes.insert(key, subtype);
        }
        for (key, localisation) in other.localisation {
            self.localisation.insert(key, localisation);
        }

        // Merge modifiers
        for (key, modifier) in other.modifiers.modifiers {
            self.modifiers.modifiers.insert(key, modifier);
        }
        for (key, subtype_modifiers) in other.modifiers.subtypes {
            self.modifiers.subtypes.insert(key, subtype_modifiers);
        }

        // Merge options - prefer non-default values
        self.options.merge_with(other.options);

        self.rule_options.merge_with(other.rule_options);
    }
}

impl EnumDefinition {
    /// Create a new simple enum definition
    pub fn new_simple(values: HashSet<String>) -> Self {
        Self {
            values,
            complex: None,
        }
    }

    /// Create a new complex enum definition
    pub fn new_complex(complex: ComplexEnumDefinition) -> Self {
        Self {
            values: HashSet::new(),
            complex: Some(complex),
        }
    }

    /// Check if this is a complex enum
    pub fn is_complex(&self) -> bool {
        self.complex.is_some()
    }

    /// Get all values (simple + complex extracted values)
    pub fn get_all_values(&self) -> &HashSet<String> {
        &self.values
    }
}

impl AliasDefinition {
    /// Create a new alias definition
    pub fn new(category: String, name: String, rules: Arc<CwtType>) -> Self {
        Self {
            category,
            name,
            to: rules,
            options: CwtOptions::default(),
        }
    }

    /// Create a new alias definition with options
    pub fn with_options(
        category: String,
        name: String,
        rules: Arc<CwtType>,
        options: CwtOptions,
    ) -> Self {
        Self {
            category,
            name,
            to: rules,
            options,
        }
    }

    /// Get the full alias key (category:name)
    pub fn full_key(&self) -> String {
        format!("{}:{}", self.category, self.name)
    }

    /// Check if this alias changes scope
    pub fn changes_scope(&self) -> bool {
        self.options.push_scope.is_some() || self.options.replace_scope.is_some()
    }
}

impl LinkDefinition {
    /// Create a new link definition
    pub fn new(name: String, input_scopes: Vec<String>, output_scope: String) -> Self {
        Self {
            name,
            desc: None,
            from_data: false,
            link_type: LinkType::Scope,
            data_source: None,
            prefix: None,
            input_scopes,
            output_scope,
        }
    }

    /// Create a link definition with description
    pub fn with_desc(mut self, desc: String) -> Self {
        self.desc = Some(desc);
        self
    }

    /// Set from_data flag
    pub fn with_from_data(mut self, from_data: bool) -> Self {
        self.from_data = from_data;
        self
    }

    /// Set link type
    pub fn with_type(mut self, link_type: LinkType) -> Self {
        self.link_type = link_type;
        self
    }

    /// Set data source
    pub fn with_data_source(mut self, data_source: String) -> Self {
        self.data_source = Some(data_source);
        self
    }

    /// Set prefix
    pub fn with_prefix(mut self, prefix: String) -> Self {
        self.prefix = Some(prefix);
        self
    }

    /// Check if this link can be used from a specific scope
    pub fn can_be_used_from(&self, scope: &str, analyzer: &CwtAnalyzer) -> bool {
        if let Some(scope_name) = analyzer.resolve_scope_name(scope) {
            return self
                .input_scopes
                .iter()
                .any(|s| s == "all" || analyzer.resolve_scope_name(s) == Some(scope_name));
        }

        false
    }

    /// Check if this link is generated from data
    pub fn is_from_data(&self) -> bool {
        self.from_data
    }
}

impl std::str::FromStr for LinkType {
    type Err = String;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "scope" => Ok(LinkType::Scope),
            "value" => Ok(LinkType::Value),
            "both" => Ok(LinkType::Both),
            _ => Err(format!("Invalid link type: {}", s)),
        }
    }
}

impl ScopeDefinition {
    /// Create a new scope definition
    pub fn new(name: String, aliases: Vec<String>) -> Self {
        Self { name, aliases }
    }

    /// Check if this scope has a specific alias
    pub fn has_alias(&self, alias: &str) -> bool {
        self.aliases.contains(&alias.to_string())
    }

    /// Get all identifiers for this scope (name + aliases)
    pub fn all_identifiers(&self) -> Vec<String> {
        let mut identifiers = vec![self.name.clone()];
        identifiers.extend(self.aliases.clone());
        identifiers
    }
}

impl ScopeGroupDefinition {
    /// Create a new scope group definition
    pub fn new(name: String, members: Vec<String>) -> Self {
        Self { name, members }
    }

    /// Check if this group contains a specific scope
    pub fn contains_scope(&self, scope: &str) -> bool {
        self.members.contains(&scope.to_string())
    }

    /// Get the number of members in this group
    pub fn member_count(&self) -> usize {
        self.members.len()
    }
}
