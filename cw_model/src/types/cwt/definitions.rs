//! Type definitions for CWT analysis
//!
//! This module contains all the data structures used to represent CWT type definitions,
//! enums, aliases, and their associated metadata.

use serde::{Deserialize, Serialize};

use super::super::inference::{InferredType, SubtypeDefinition};
use std::{
    collections::{HashMap, HashSet},
    str::FromStr,
};

/// Definition of a CWT type
#[derive(Debug, Clone)]
pub struct TypeDefinition {
    /// Path where this type is found
    pub path: Option<String>,
    /// Name field override
    pub name_field: Option<String>,
    /// Skip root key configuration
    pub skip_root_key: Option<SkipRootKey>,
    /// Subtypes definitions
    pub subtypes: HashMap<String, SubtypeDefinition>,
    /// Localisation requirements
    pub localisation: HashMap<String, LocalisationRequirement>,
    /// Modifiers generated by this type
    pub modifiers: ModifierGeneration,
    /// Type validation rules
    pub rules: InferredType,
    /// Type-specific options
    pub options: TypeOptions,
}

/// Options for subtypes
#[derive(Debug, Clone, Default)]
pub struct SubtypeOptions {
    /// Display name for this subtype
    pub display_name: Option<String>,
    /// Abbreviation for graph displays
    pub abbreviation: Option<String>,
    /// Scope to push when this subtype is active
    pub push_scope: Option<String>,
    /// Key filter for this subtype
    pub type_key_filter: Option<TypeKeyFilter>,
    /// Starts with filter
    pub starts_with: Option<String>,
    /// Severity level for this subtype
    pub severity: Option<SeverityLevel>,
}

/// Options for types
#[derive(Debug, Clone, Default)]
pub struct TypeOptions {
    /// Whether this type is unique
    pub unique: bool,
    /// Whether to start types from file root
    pub type_per_file: bool,
    /// Path strictness
    pub path_strict: bool,
    /// Specific file to match
    pub path_file: Option<String>,
    /// File extension filter
    pub path_extension: Option<String>,
    /// Graph related types
    pub graph_related_types: Vec<String>,
    /// Starts with filter
    pub starts_with: Option<String>,
    /// Severity level for errors
    pub severity: Option<SeverityLevel>,
    /// Type key filter
    pub type_key_filter: Option<TypeKeyFilter>,
}

/// Type key filter configuration
#[derive(Debug, Clone)]
pub enum TypeKeyFilter {
    /// Must have specific key
    Specific(String),
    /// Must have one of these keys
    OneOf(Vec<String>),
    /// Must not have specific key
    Not(String),
}

/// Severity levels for validation
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub enum SeverityLevel {
    Error,
    Warning,
    Information,
    Hint,
}

impl FromStr for SeverityLevel {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "error" => Ok(SeverityLevel::Error),
            "warning" => Ok(SeverityLevel::Warning),
            "information" => Ok(SeverityLevel::Information),
            "hint" => Ok(SeverityLevel::Hint),
            _ => Err(format!("Invalid severity level: {}", s)),
        }
    }
}

/// Skip root key configuration
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum SkipRootKey {
    /// Skip specific key
    Specific(String),
    /// Skip any key
    Any,
    /// Skip any key except specific ones
    Except(Vec<String>),
    /// Skip multiple levels in sequence
    Multiple(Vec<String>),
}

/// Localisation requirement for a type
#[derive(Debug, Clone)]
pub struct LocalisationRequirement {
    /// Localisation key pattern
    pub pattern: String,
    /// Whether this localisation is required
    pub required: bool,
    /// Whether this is the primary localisation
    pub primary: bool,
    /// Subtype-specific localisation
    pub subtypes: HashMap<String, HashMap<String, String>>,
}

impl LocalisationRequirement {
    /// Create a new localisation requirement
    pub fn new(pattern: String) -> Self {
        Self {
            pattern,
            required: false,
            primary: false,
            subtypes: HashMap::new(),
        }
    }

    /// Create a required localisation requirement
    pub fn required(pattern: String) -> Self {
        Self {
            pattern,
            required: true,
            primary: false,
            subtypes: HashMap::new(),
        }
    }

    /// Create a primary localisation requirement
    pub fn primary(pattern: String) -> Self {
        Self {
            pattern,
            required: false,
            primary: true,
            subtypes: HashMap::new(),
        }
    }
}

/// Definition of a CWT enum
#[derive(Debug, Clone)]
pub struct EnumDefinition {
    /// Simple enum values
    pub values: HashSet<String>,
    /// Complex enum configuration
    pub complex: Option<ComplexEnumDefinition>,
}

/// Configuration for complex enums
#[derive(Debug, Clone)]
pub struct ComplexEnumDefinition {
    /// Path to scan for enum values
    pub path: String,
    /// Structure to match for enum extraction
    pub name_structure: InferredType,
    /// Whether to start from file root
    pub start_from_root: bool,
}

/// Definition of a CWT alias
#[derive(Debug, Clone)]
pub struct AliasDefinition {
    /// Alias category (e.g., "effect", "trigger")
    pub category: String,
    /// Alias name/key
    pub name: String,
    /// Alias rules
    pub rules: InferredType,
}

/// Enhanced modifier generation for types
#[derive(Debug, Clone)]
pub struct ModifierGeneration {
    /// Base modifier patterns with their scope categories
    pub modifiers: HashMap<String, String>,
    /// Subtype-specific modifier generation
    pub subtypes: HashMap<String, HashMap<String, String>>,
}

impl TypeDefinition {
    /// Create a new type definition with default values
    pub fn new(rules: InferredType) -> Self {
        Self {
            path: None,
            name_field: None,
            skip_root_key: None,
            subtypes: HashMap::new(),
            localisation: HashMap::new(),
            modifiers: ModifierGeneration {
                modifiers: HashMap::new(),
                subtypes: HashMap::new(),
            },
            rules,
            options: TypeOptions::default(),
        }
    }

    /// Check if this type has a specific path
    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    /// Check if this type has subtypes
    pub fn has_subtypes(&self) -> bool {
        !self.subtypes.is_empty()
    }

    /// Check if this type has localisation requirements
    pub fn has_localisation(&self) -> bool {
        !self.localisation.is_empty()
    }
}

impl EnumDefinition {
    /// Create a new simple enum definition
    pub fn new_simple(values: HashSet<String>) -> Self {
        Self {
            values,
            complex: None,
        }
    }

    /// Create a new complex enum definition
    pub fn new_complex(complex: ComplexEnumDefinition) -> Self {
        Self {
            values: HashSet::new(),
            complex: Some(complex),
        }
    }

    /// Check if this is a complex enum
    pub fn is_complex(&self) -> bool {
        self.complex.is_some()
    }

    /// Get all values (simple + complex extracted values)
    pub fn get_all_values(&self) -> &HashSet<String> {
        &self.values
    }
}

impl AliasDefinition {
    /// Create a new alias definition
    pub fn new(category: String, name: String, rules: InferredType) -> Self {
        Self {
            category,
            name,
            rules,
        }
    }

    /// Get the full alias key (category:name)
    pub fn full_key(&self) -> String {
        format!("{}:{}", self.category, self.name)
    }
}
